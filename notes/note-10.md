> 数组和指针

- static

- `&` `*`

- 初始化指针

- 指针与数组的关系

- 二维数组

- 数组由数据类型相同的一系列元素组成

- const 声明数组为只读

- 存储类型警告

- 自动存储类别

- sizeof，整个数组的大小（以字节为单位）

- 指定初始化器
  - 初始化指定的数组元素

- 后面的初始化会取代前面的初始化

- 未指定数组大小，编译器会把数组的大小设置为足够装得下初始化的值

- 数组赋值
  - 不允许把数组作为一个单元赋给另一个数组

- 数组边界

- 指定数组的大小

- 变长数组

```
float rain[5][12]
```

- 初始化二维数组
  - 初始化时也可省略内部的花括号

- 多维数组

- 指针和数组

- 指针提供一种以符号形式使用地址的方法

- 指针能有效处理数组

- 地址按字节编址
- 指针+1是增加一个存储单元

- 对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址

- 指针的值是它所指向对象的地址

- 可以使用指针标识数组的元素和获得元素的值
  - 同一个对象有两种表示法

- 间接运算符* 的优先级高于+

- 函数、数组、指针

- 数组当做函数的参数，将会退化为指针，使用时需要解引用

- 使用指针形参

- 指针表示法
- 数组表示法

- 处理数组的函数实际上用指针作为参数

- 8种指针操作
  - 赋值
  - 解引用
  - 取址，指针本身的地址
  - 指针与整数相加
  - 递增指针
  - 递减指针
  - 指针减去一个整数
  - 指针求差，可以计算出两个指针的差值
  - 比较，使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象

- 不能解引用未初始化的指针

- 在使用指针之前，必须先用已分配的地址初始化它

- 指针数组、函数指针、指向指针的指针数组、指向函数的指针数组

- 基本用法：
  - 在函数间传递信息
  - 用在处理数组的函数中

- 创建 const数组、const指针、指向const的指针

- const可以声明一个不能指向别处的地址的指针

- 在创建指针时还可以使用const两次，该指针既不能更改它所指向的地址，也不能修改指向地址上的值

- 指针与多维数组

- 地址的地址或指针是双重间接

- `zippo[0]` 和`*zippo`完全相同
- 对二维数组名解引用两次得到存储在数组中的值

- 指针表示法 `(*(*(zippo + 2) + 1))`
- 数组表示法 `(zippo[2][1])`

- 指向二维数组

```c
int (*pz)[4];
// 使用圆括号是因为[]优先级大于*
```

- 指针之间的赋值比数值类型之间的赋值要严格
- 不能将不同类型的指针互相赋值

- 把const指针赋给非const指针不安全

- C和C++中const的用法很相似，但是并不完全相同。
  - 区别之一是，C++允许在声明数组大小时使用const整数，而C却不允许。
  - 区别之二是，C++的指针赋值检查更严格

- 要编写处理二维数组的函数，首先要正确理解指针才能写出声明函数的形参

```c
void somefunction(int (*pt)[4]);
void somefn(int pt[][4]);
```

- 变长数组 variable-length arrays，允许使用变量表示数组的纬度

- 前面提到过，变长数组有一些限制。变长数组必须是自动存储类别，这意味着无论在函数中声明还是作为函数形参声明，都不能使用static或extern存储类别说明符

- 变长数组无法改变大小

```c
int sum(int rows, int cols, int ar[rows][cols]);

int sum2d(int, int, int [*][*]);
```

- 变长数组还允许动态分配内存，可以在程序运行时指定数组的大小

- 复合字面量
  - 字面量是除符号常量之外的常量

- 匿名的

```c
int diva[2] = {10, 20};

(int [2]){10, 20} // 复合字面量

int *ptr;
pt1 = (int [2]){10, 20};
```

- 复合字面量是提供只临时需要的值的一种手段
- 复合字面量具有作用域